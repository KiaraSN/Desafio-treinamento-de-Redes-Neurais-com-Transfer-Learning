# -*- coding: utf-8 -*-
"""Cat and Dog Desafio-treinamento-de-Redes-Neurais-com-Transfer-Learning.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zhzj0BdMQ_SGpe9I0Go4x7MNV4yxaffe
"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import os
import random
import numpy as np
import matplotlib.pyplot as plt
import tensorflow as tf
from tensorflow.keras.preprocessing import image
from tensorflow.keras.applications.imagenet_utils import preprocess_input
from tensorflow.keras.models import Sequential, Model
from tensorflow.keras.layers import Dense, Dropout, Flatten, Activation, Conv2D, MaxPooling2D
from tensorflow.keras.applications import VGG16

print("TensorFlow version:", tf.__version__)

import tensorflow_datasets as tfds

(ds_train, ds_val), ds_info = tfds.load(
    'cats_vs_dogs',
    split=['train[:85%]', 'train[85%:]'],  # 85/15 split
    shuffle_files=True,
    as_supervised=True,  # retorna (imagem, label)
    with_info=True
)

num_classes = ds_info.features['label'].num_classes
print("NÃºmero de classes:", num_classes)

IMG_SIZE = 224

def preprocess(img, label):
    img = tf.image.resize(img, (IMG_SIZE, IMG_SIZE))
    img = img / 255.0
    label = tf.one_hot(label, num_classes)
    return img, label

ds_train = ds_train.map(preprocess).shuffle(1000).batch(32).prefetch(tf.data.AUTOTUNE)
ds_val   = ds_val.map(preprocess).batch(32).prefetch(tf.data.AUTOTUNE)

for img, lbl in ds_train.take(1):
    plt.figure(figsize=(16,4))
    for i in range(8):
        plt.subplot(1,8,i+1)
        plt.imshow(img[i])
        plt.axis('off')
    plt.show()

model = Sequential([
    Conv2D(32, (3,3), activation='relu', input_shape=(IMG_SIZE, IMG_SIZE,3)),
    MaxPooling2D(2,2),
    Conv2D(32, (3,3), activation='relu'),
    MaxPooling2D(2,2),
    Dropout(0.25),
    Flatten(),
    Dense(256, activation='relu'),
    Dropout(0.5),
    Dense(num_classes, activation='softmax')
])

model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])
model.summary()

history = model.fit(
    ds_train,
    validation_data=ds_val,
    epochs=5
)

plt.figure(figsize=(12,5))

plt.subplot(1,2,1)
plt.plot(history.history['loss'], label='train_loss')
plt.plot(history.history['val_loss'], label='val_loss')
plt.title('Loss')
plt.xlabel('Epochs')
plt.legend()

plt.subplot(1,2,2)
plt.plot(history.history['accuracy'], label='train_acc')
plt.plot(history.history['val_accuracy'], label='val_acc')
plt.title('Accuracy')
plt.xlabel('Epochs')
plt.legend()
plt.show()

loss, acc = model.evaluate(ds_val)
print("Test loss:", loss)
print("Test accuracy:", acc)

base_model = VGG16(weights='imagenet', include_top=False, input_shape=(IMG_SIZE, IMG_SIZE,3))
base_model.trainable = False

model_vgg = Sequential([
    base_model,
    Flatten(),
    Dense(256, activation='relu'),
    Dropout(0.5),
    Dense(num_classes, activation='softmax')
])

model_vgg.compile(optimizer=tf.keras.optimizers.Adam(0.0001),
                  loss='categorical_crossentropy',
                  metrics=['accuracy'])
model_vgg.summary()

history_vgg = model_vgg.fit(
    ds_train,
    validation_data=ds_val,
    epochs=5
)

plt.figure(figsize=(12,5))

plt.subplot(1,2,1)
plt.plot(history.history['val_loss'], label='CNN_val_loss')
plt.plot(history_vgg.history['val_loss'], label='VGG_val_loss')
plt.title('Validation Loss')
plt.xlabel('Epochs')
plt.legend()

plt.subplot(1,2,2)
plt.plot(history.history['val_accuracy'], label='CNN_val_acc')
plt.plot(history_vgg.history['val_accuracy'], label='VGG_val_acc')
plt.title('Validation Accuracy')
plt.xlabel('Epochs')
plt.legend()
plt.show()

loss, acc = model_vgg.evaluate(ds_val)
print("VGG16 - Test loss:", loss)
print("VGG16 - Test accuracy:", acc)

def predict_image(model, img_path):
    img = image.load_img(img_path, target_size=(IMG_SIZE, IMG_SIZE))
    x = image.img_to_array(img)
    x = np.expand_dims(x, axis=0)
    x = preprocess_input(x)
    pred = model.predict(x)
    return pred

# Substitua por um caminho de imagem Cats vs Dogs local ou do dataset
for img, lbl in ds_val.take(1):
    sample_img = img[0].numpy()
    plt.imshow(sample_img)
    plt.axis('off')
    plt.show()

base_model.trainable = True

for layer in base_model.layers[:-4]:
    layer.trainable = False

model_vgg.compile(optimizer=tf.keras.optimizers.Adam(1e-5),
                  loss='categorical_crossentropy',
                  metrics=['accuracy'])

history_vgg_ft = model_vgg.fit(
    ds_train,
    validation_data=ds_val,
    epochs=3
)

loss, acc = model_vgg.evaluate(ds_val)
print("VGG16 fine-tuned - Test loss:", loss)
print("VGG16 fine-tuned - Test accuracy:", acc)

plt.figure(figsize=(12,5))
plt.subplot(1,2,1)
plt.plot(history.history['val_loss'], label='CNN_val_loss')
plt.plot(history_vgg.history['val_loss'], label='VGG_val_loss')
plt.plot(history_vgg_ft.history['val_loss'], label='VGG_ft_val_loss')
plt.title('Validation Loss')
plt.xlabel('Epochs')
plt.legend()

plt.subplot(1,2,2)
plt.plot(history.history['val_accuracy'], label='CNN_val_acc')
plt.plot(history_vgg.history['val_accuracy'], label='VGG_val_acc')
plt.plot(history_vgg_ft.history['val_accuracy'], label='VGG_ft_val_acc')
plt.title('Validation Accuracy')
plt.xlabel('Epochs')
plt.legend()
plt.show()

loss, acc = model_vgg.evaluate(ds_val)
print("Final VGG16 - Test loss:", loss)
print("Final VGG16 - Test accuracy:", acc)

model_vgg.save("cats_vs_dogs_vgg16.h5")

from tensorflow.keras.models import load_model
model_loaded = load_model("cats_vs_dogs_vgg16.h5")